<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>时钟，启动！</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'">
    <style>
        canvas {
            background-color: white;
            border-radius: 50%;
        }
    </style>
    <link rel="stylesheet" href="assets/css/mdui.min.css">
    <script src="assets/js/mdui.min.js"></script>
</head>
<body>

<canvas id="clock" width="400" height="400"></canvas>
<video id="videoPlayer" autoplay loop>
    <source src="../data/play.mp4" type="video/mp4">
    Your browser does not support the video tag.
</video>


<script>
    const { ipcRenderer } = require('electron');
    const canvas = document.getElementById('clock');
    const ctx = canvas.getContext('2d');
    const radius = canvas.width / 2;
    ctx.translate(radius, radius);


    async function fetchConfigAndStartClock() {
        const config = await ipcRenderer.invoke('get-config');
        let useNetworkTime = config["network-time"];
        startClock(useNetworkTime);
    }

    function drawClock() {
        drawFace(ctx, radius);
        drawNumbers(ctx, radius);
        drawCenter(ctx);
    }

    function drawFace(ctx, radius) {
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, 2 * Math.PI);
        ctx.fillStyle = 'white'; // 白色表盘
        ctx.fill();
        ctx.strokeStyle = '#000'; // 黑色边框
        ctx.lineWidth = radius * 0.05;
        ctx.stroke();
    }

    function drawNumbers(ctx, radius) {
        ctx.font = radius * 0.15 + "px arial";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillStyle = '#000'; // 黑色数字
        for (let num = 1; num <= 12; num++) {
            let ang = num * Math.PI / 6;
            ctx.rotate(ang);
            ctx.translate(0, -radius * 0.85);
            ctx.rotate(-ang);
            ctx.fillText(num.toString(), 0, 0);
            ctx.rotate(ang);
            ctx.translate(0, radius * 0.85);
            ctx.rotate(-ang);
        }
    }

    function drawCenter(ctx) {
        ctx.beginPath();
        ctx.arc(0, 0, radius * 0.05, 0, 2 * Math.PI);
        ctx.fillStyle = '#000'; // 黑色中心点
        ctx.fill();
    }

    async function getCurrentTime(useNetworkTime) {
        let now;

            if (useNetworkTime) {
                const response = await fetch('https://api.zyghit.cn/time-aligned');
                if (!response.ok) {
                    throw new Error('Failed to fetch network time');
                }
                const data = await response.json();
                if (!data.time) {
                    throw new Error('Invalid time data');
                }
                // Unix时间戳转换为Date对象
                now = new Date(parseInt(data.time));
                console.log(now)
            } else {
                now = new Date();
            }


        const hour = now.getHours() % 12;
        const minute = now.getMinutes();
        const second = now.getSeconds();
        const millisecond = now.getMilliseconds();

        return {
            hour: (hour * Math.PI / 6) + (minute * Math.PI / 360) + (second * Math.PI / 21600),
            minute: (minute * Math.PI / 30) + (second * Math.PI / 1800),
            second: (second * Math.PI / 30) + (millisecond * Math.PI / 30000)
        };
    }

    function drawHand(ctx, pos, length, width) {
        ctx.beginPath();
        ctx.lineWidth = width;
        ctx.lineCap = "block";
        ctx.strokeStyle = '#000'; // 黑色指针
        ctx.moveTo(0, 0);
        ctx.rotate(pos);
        ctx.lineTo(0, -length);
        ctx.stroke();
        ctx.rotate(-pos);
    }

    function startClock(useNetworkTime) {
        getCurrentTime(useNetworkTime).then((endAngles) => {
            let startTime = Date.now();
            let durations = {
                second: 3000, // 秒针动画持续时间 1秒
                minute: 2000, // 分针动画持续时间 2秒
                hour: 1000    // 时针动画持续时间 3秒
            };

            const animate = () => {
                let currentTime = Date.now();
                let elapsed = currentTime - startTime;

                ctx.clearRect(-radius, -radius, canvas.width, canvas.height);
                drawClock();

                const secondAngle = elapsed < durations.second
                    ? (elapsed / durations.second) * endAngles.second
                    : endAngles.second;

                const minuteAngle = elapsed < durations.minute
                    ? (elapsed / durations.minute) * endAngles.minute
                    : endAngles.minute;

                const hourAngle = elapsed < durations.hour
                    ? (elapsed / durations.hour) * endAngles.hour
                    : endAngles.hour;

                drawHand(ctx, hourAngle, radius * 0.5, radius * 0.05);
                drawHand(ctx, minuteAngle, radius * 0.8, radius * 0.05);
                drawHand(ctx, secondAngle, radius * 0.9, radius * 0.02);

                if (elapsed < durations.hour || elapsed < durations.minute || elapsed < durations.second) {
                    requestAnimationFrame(animate);
                } else {
                    // 动画结束后，开始正常的无级更新
                    const smoothTimeUpdate = async () => {
                        ctx.clearRect(-radius, -radius, canvas.width, canvas.height);
                        drawClock();
                        const currentAngles = await getCurrentTime(useNetworkTime);
                        drawHand(ctx, currentAngles.hour, radius * 0.5, radius * 0.05);
                        drawHand(ctx, currentAngles.minute, radius * 0.8, radius * 0.05);
                        drawHand(ctx, currentAngles.second, radius * 0.9, radius * 0.02);
                        requestAnimationFrame(smoothTimeUpdate);
                    };
                    smoothTimeUpdate();
                }
            };

            animate();
        });
    }

    fetchConfigAndStartClock(); // 获取配置并启动时钟
</script>
</body>
</html>
